---
title: "Gene expression - microarray data still useful"
author: "Pietro Delfino"
date:  "2019-07-18"
tags:
- R coding
- ggplot
- statistics
- microarray
- gene expression
- bioinformatics
categories:
- R
- stats
- ggplot
- bioinformatics
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(reshape2)
library(GEOquery)
library(DT)
library(knitr)
```

I work on pancreatic cancer **-omics**. Data mining on published data is a real source of gold today when someone wants to find confirmation of an hypothesis on a more general scale than his own dataset.

The most common -omics datasets out there are transcriptomics one; both RNA-Seq and good ol' microarray. Regarding RNA-Seq, the well known TCGA and ICGC are my starting point for any explorative data mining analysis.

Regarding microarray, few studies with clear data have been published in the past, and someone has already collected the most interesting ones (see [Birnbaum et al. 2017](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5674743/), [Zhao et al. 2018](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5975421/)).

For the scopes of my research I have also explored some of these datasets. The majority of theme are stored in the [GEO database](https://www.ncbi.nlm.nih.gov/geo/).

Here I want to present a basic workflow to retrieve a microarray expression dataset from GEO and to perform basic explorative analysis in ***R***. As an example I take [GSE62165](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE62165) dataset.

To download and access data I use the *Bioconductor* `GEOquery` package (https://bioconductor.org/packages/release/bioc/html/GEOquery.html).

```{r message=FALSE, warning=FALSE, dev='svg',eval=FALSE}
# Load some libraries
library(tidyverse)
library(reshape2)
library(ggsci)
library(GEOquery)

# Downlaod ExpressionSet
x <- getGEO('GSE62165', destdir = 'your/favourite/path', getGPL = T)
```

We have downloaded the *GSE series matrix* to file and the *GPL .soft annotation*.
Now we load them back.

```{r message=FALSE, warning=FALSE, dev='svg', eval=FALSE}
x <- getGEO(filename = 'your/favourite/path/GSE62165_series_matrix.txt.gz')
```

```{r message=FALSE, warning=FALSE, dev='svg', include=FALSE}
x <- getGEO(filename = 'GSE62165_series_matrix.txt.gz')
```

Then we can start exploring the data

```{r message=FALSE, warning=FALSE, dev='svg', results='asis'}
# First we save the expression matrix in a different object
mat <- exprs(x)

dim(mat)

kable(mat[1:8, 1:5], caption = 'Few lines of the expression matrix')
```

Then we explore the distrbution of samples' expression values with a boxplot

```{r message=FALSE, warning=FALSE, dev='svg', results='asis'}
boxplot(mat, outline=F, main='GSE62165')
```

What about annotation data? They are stored in `fData` slot. We save them in a unique object and look for the **Gene Symbol** column, that we will use to replace row names (probes id).

```{r message=FALSE, warning=FALSE, dev='svg', results='asis'}
ann <- fData(x)

colnames(ann)

# Subset to columns we'll use
ann <- ann[,c('ID', 'Gene Symbol')]
```

For my project I need to work only with cancer samples, so we explore **pheno data**, stored in the slot `pData` to identify them.

```{r message=FALSE, warning=FALSE, dev='svg'}
phenodata <- pData(x)

# From here https://stackoverflow.com/questions/51316238/find-substring-in-dataframe-in-r I found I nice way to identify the position of a string in the entire dataframe; 
# I am looking for the word tumor (or similar) that usually is not in the colnames
unique(which(array(grepl("\\btumor\\b",as.matrix(phenodata)),dim(phenodata)),T)[,2])
```

```{r message=FALSE, warning=FALSE, dev='svg'}
# The word is included in the columns 10 and 39; let's check them
datatable(phenodata[,c(10,39)])
```

Subset to the columns we will need. In particular column `tissue:ch1` that has a more clear nomenclature.

```{r message=FALSE, warning=FALSE, dev='svg'}
# We also rename the column
phenodata <- data.frame(tissue = phenodata[,39])
```

We use the info contained in this column to subset the matrix to only the cancer samples. We remember that original matrix had 131 samples (columns).

```{r message=FALSE, warning=FALSE, dev='svg'}
mat <- mat[, !grepl('non-tumoral', phenodata$tissue)]

dim(mat)
```

We are left with 118 samples.

Since my final aim is to apply some particular functions that need one row per gene, we have to face the neverending problem of having multiple probes matching to the same gene. We saw that in total we have more than 40K probe IDs. So we surely have genes with more than one probe matching.

Here I apply the average over multiple probes. I know that this is an approximation, but here we really need to have a single gene for each patients (also I take with very high consideration the words from Gordon Smyth https://support.bioconductor.org/p/44161/)

I know that there is the `avereps` function from `limma` package, but I like to write my own scripts, so I wrote a script with the **tidyverse** style that makes use of `group_by` and `summarize` functions. We use the annotation df to find out which genes have multiple probes.

```{r message=FALSE, warning=FALSE, dev='svg'}
# Save to new object
mat_mean <- mat %>% 
    as.data.frame() %>% 
    rownames_to_column('ID') %>%  
    left_join(ann, by='ID') %>% 
    dplyr::select(-ID) %>% 
    dplyr::rename(SYMBOL = 'Gene Symbol') %>%
    # remove NAs
    dplyr::filter(!is.na(SYMBOL)) %>%
    # remove empty values
    dplyr::filter(!SYMBOL == '') %>%
    # find the groups by genes
    group_by(SYMBOL) %>% 
    # apply mean by these groups 
    summarize_all(.funs = mean, na.rm=T) %>%  
    # go back to matrix format
    column_to_rownames('SYMBOL') %>% 
    as.matrix()

kable(mat_mean[1:8, 1:5], caption = 'Few lines of the expression matrix with averaged probes')
```

Now we have a sort of gene expression matrix ready to be used for cool things.
Before, I would like to show another `tidyverse` method for obtaining histograms for each sample of the expression matrix. Sometimes it is useful, besides boxplot, to spot strange samples.

```{r message=FALSE, warning=FALSE, dev='svg'}
# Since we are dealing with a lot of samples, we'll plot a subset
mat_mean[,1:16] %>% 
    as.data.frame() %>%
    rownames_to_column('ID') %>% 
    melt() %>%
    
    ggplot(aes(value)) +
    geom_histogram() +
    facet_wrap(~variable)
```















